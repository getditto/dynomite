<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Dynomite is the set of high-level interfaces making interacting with AWS DynamoDB more productive."><meta name="keywords" content="rust, rustlang, rust-lang, dynomite"><title>dynomite - Rust</title><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../light.css"  id="themeStyle"><link rel="stylesheet" type="text/css" href="../dark.css" disabled ><link rel="stylesheet" type="text/css" href="../ayu.css" disabled ><script id="default-settings"></script><script src="../storage.js"></script><script src="../crates.js"></script><noscript><link rel="stylesheet" href="../noscript.css"></noscript><link rel="icon" type="image/svg+xml" href="../favicon.svg">
<link rel="alternate icon" type="image/png" href="../favicon-16x16.png">
<link rel="alternate icon" type="image/png" href="../favicon-32x32.png"><style type="text/css">#crate-search{background-image:url("../down-arrow.svg");}</style></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu" role="button">&#9776;</div><a href='../dynomite/index.html'><div class='logo-container rust-logo'><img src='../rust-logo.png' alt='logo'></div></a><h2 class="location">Crate dynomite</h2><div class="block version"><p>Version 0.10.0</p></div><div class="sidebar-elems"><a id="all-types" href="all.html"><p>See all dynomite's items</p></a><div class="block items"><ul><li><a href="#modules">Modules</a></li><li><a href="#macros">Macros</a></li><li><a href="#traits">Traits</a></li><li><a href="#types">Type Definitions</a></li></ul></div><div id="sidebar-vars" data-name="dynomite" data-ty="mod" data-relpath=""></div><script defer src="sidebar-items.js"></script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu" title="themes"><img src="../brush.svg" width="18" height="18" alt="Pick another theme!"></button><div id="theme-choices" role="menu"></div></div><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" disabled autocomplete="off" spellcheck="false" placeholder="Click or press ‚ÄòS‚Äô to search, ‚Äò?‚Äô for more options‚Ä¶" type="search"></div><button type="button" id="help-button" title="help">?</button><a id="settings-menu" href="../settings.html" title="settings"><img src="../wheel.svg" width="18" height="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class="fqn"><span class="in-band">Crate <a class="mod" href="#">dynomite</a><button id="copy-path" onclick="copy_path(this)" title="copy path"><img src="../clipboard.svg" width="19" height="18" alt="Copy item import" title="Copy item import to clipboard"></button></span><span class="out-of-band"><span id="render-detail"><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span><a class="srclink" href="../src/dynomite/lib.rs.html#1-1433" title="goto source code">[src]</a></span></h1><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Dynomite is the set of high-level interfaces making interacting with <a href="https://aws.amazon.com/dynamodb/">AWS DynamoDB</a> more productive.</p>
<p>üí°To learn more about DynamoDB, see <a href="https://www.dynamodbguide.com/">this helpful guide</a>.</p>
<h2 id="data-modeling" class="section-header"><a href="#data-modeling">Data Modeling</a></h2>
<p>Dynomite adapts Rust‚Äôs native types to
DynamoDB‚Äôs <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.CoreComponents.html">core components</a>
to form a coherent interface.</p>
<p>The <a href="trait.Attribute.html">Attribute</a> type
provides conversion interfaces to and from Rust‚Äôs native scalar types which represent
DynamoDB‚Äôs notion of ‚Äúattributes‚Äù. The goal of this type is to make representing
AWS typed values feel more natural and ergonomic in Rust. Where a conversion is not available you can implement <code>Attribute</code> for your own
types to leverage higher level functionality.</p>
<p>The <a href="trait.Item.html">Item</a> trait
provides conversion interfaces for complex types which represent
DynamoDB‚Äôs notion of ‚Äúitems‚Äù.</p>
<p>üí° A cargo feature named <code>&quot;derive&quot;</code> makes it easy to derive <code>Item</code> instances for your custom types. This feature is enabled by default.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
 <span class="kw">use</span> <span class="ident">dynomite</span>::{<span class="ident">Item</span>, <span class="ident">Attributes</span>};
 <span class="kw">use</span> <span class="ident">uuid::Uuid</span>;

<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Item</span>)]</span>
<span class="kw">struct</span> <span class="ident">Order</span> {
  <span class="attribute">#[<span class="ident">dynomite</span>(<span class="ident">partition_key</span>)]</span>
  <span class="ident">user</span>: <span class="ident">Uuid</span>,
  <span class="attribute">#[<span class="ident">dynomite</span>(<span class="ident">sort_key</span>)]</span>
  <span class="ident">order_id</span>: <span class="ident">Uuid</span>,
  <span class="ident">color</span>: <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">String</span><span class="op">&gt;</span>,
}</pre></div>
<h2 id="attributes" class="section-header"><a href="#attributes">Attributes</a></h2><h3 id="deriveitem" class="section-header"><a href="#deriveitem"><code>#[derive(Item)]</code></a></h3>
<p>Used to define a top-level DynamoDB item.
Generates a <code>&lt;ItemName&gt;Key</code> struct with only <code>partition_key/sort_key</code>
fields to be used for type-safe primary key construction.
This automatically derives <a href="#deriveattributes"><code>Attributes</code></a> too.</p>
<p>For the <code>Order</code> struct from the example higher this will generate an <code>OrderKey</code>
struct like this:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Attributes</span>)]</span>
<span class="kw">struct</span> <span class="ident">OrderKey</span> {
    <span class="ident">user</span>: <span class="ident">Uuid</span>,
    <span class="ident">order_id</span>: <span class="ident">Uuid</span>,
}</pre></div>
<p>Use it to safely and conveniently construct the primary key:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">dynomite</span>::{
    <span class="ident">dynamodb</span>::{<span class="ident">DynamoDb</span>, <span class="ident">GetItemInput</span>},
    <span class="ident">Attributes</span>, <span class="ident">FromAttributes</span>,
};
<span class="kw">use</span> <span class="ident">std</span>::{<span class="ident">convert::TryFrom</span>, <span class="ident">error::Error</span>};
<span class="kw">use</span> <span class="ident">uuid::Uuid</span>;

<span class="kw">async</span> <span class="kw">fn</span> <span class="ident">get_order</span>(
    <span class="ident">client</span>: <span class="kw">impl</span> <span class="ident">DynamoDb</span>,
    <span class="ident">user</span>: <span class="ident">Uuid</span>,
    <span class="ident">order_id</span>: <span class="ident">Uuid</span>,
) <span class="op">-</span><span class="op">&gt;</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">Order</span><span class="op">&gt;</span>, <span class="ident">Box</span><span class="op">&lt;</span><span class="kw">dyn</span> <span class="ident">Error</span><span class="op">&gt;</span><span class="op">&gt;</span> {
    <span class="comment">// Use the generated `OrderKey` struct to create a primary key</span>
    <span class="kw">let</span> <span class="ident">key</span> <span class="op">=</span> <span class="ident">OrderKey</span> { <span class="ident">user</span>, <span class="ident">order_id</span> };
    <span class="comment">// Convert stronly-typed `OrderKey` to a map of `rusoto_dynamodb::AttributeValue`</span>
    <span class="kw">let</span> <span class="ident">key</span>: <span class="ident">Attributes</span> <span class="op">=</span> <span class="ident">key</span>.<span class="ident">into</span>();

    <span class="kw">let</span> <span class="ident">result</span> <span class="op">=</span> <span class="ident">client</span>
        .<span class="ident">get_item</span>(<span class="ident">GetItemInput</span> {
            <span class="ident">table_name</span>: <span class="string">&quot;orders&quot;</span>.<span class="ident">into</span>(),
            <span class="ident">key</span>,
            ..<span class="ident">Default::default</span>()
        })
        .<span class="kw">await</span><span class="question-mark">?</span>;

    <span class="prelude-val">Ok</span>(<span class="ident">result</span>
        .<span class="ident">item</span>
        .<span class="ident">map</span>(<span class="op">|</span><span class="ident">item</span><span class="op">|</span> <span class="ident">Order::try_from</span>(<span class="ident">item</span>).<span class="ident">expect</span>(<span class="string">&quot;Invalid order, db corruption?&quot;</span>)))
}</pre></div>
<ul>
<li>
<p><code>#[dynomite(partition_key)]</code> - required attribute, expected to be applied the target
<a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.CoreComponents.html#HowItWorks.CoreComponents.PrimaryKey">partition attribute</a> field with a derivable DynamoDB attribute value
of String, Number or Binary</p>
</li>
<li>
<p><code>#[dynomite(sort_key)]</code> - optional attribute, may be applied to one target
<a href="sort-key">sort attribute</a> field with an derivable DynamoDB attribute value
of String, Number or Binary</p>
</li>
<li>
<p>All other attributes are the same as for <a href="#deriveattributes"><code>#[derive(Attributes)]</code></a></p>
</li>
</ul>
<h3 id="deriveattributes" class="section-header"><a href="#deriveattributes"><code>#[derive(Attributes)]</code></a></h3>
<p>Used to derive an implementation of <code>From/IntoAttributes</code> trait to allow for
serializing/deserializing map-like types into <a href="https://docs.rs/rusoto_dynamodb/*/rusoto_dynamodb/struct.AttributeValue.html"><code>AttributeValue</code></a>.
This also generates <code>TryFrom&lt;Attributes&gt;</code> and <code>Into&lt;Attributes&gt;</code> implementations.</p>
<ul>
<li>
<p><code>#[dynomite(rename = &quot;actualName&quot;)]</code> - optional attribute, may be applied to any item
attribute field, useful when the DynamoDB table you‚Äôre interfacing with has
attributes whose names don‚Äôt following Rust‚Äôs naming conventions</p>
</li>
<li>
<p><code>#[dynomite(skip_serializing_if = &quot;expr_that_returns_function&quot;)]</code> - place this on a field
that should be skipped in the output map entirely if the given function returns <code>true</code>.
The value of this attribute must be a path to a function that satisfies the signature
<code>FnOnce(&amp;T) -&gt; bool</code>, where <code>T</code> is the field type (possibly after some auto-deref coertions).</p>
<p>This is is inspired by <a href="https://serde.rs/attr-skip-serializing.html"><code>#[serde(skip_serializing_if = &quot;...&quot;)]</code></a>.</p>
<p>This attribute may be used to skip serializing the empty set for example
(which is not supported by current DynamoDB version, but it may be in future).</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">dynomite::Attributes</span>;
<span class="kw">use</span> <span class="ident">std::collections::HashSet</span>;

<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Attributes</span>)]</span>
<span class="kw">struct</span> <span class="ident">UniqueStrings</span> {
    <span class="attribute">#[<span class="ident">dynomite</span>(<span class="ident">skip_serializing_if</span> <span class="op">=</span> <span class="string">&quot;HashSet::is_empty&quot;</span>)]</span>
    <span class="ident">strings</span>: <span class="ident">HashSet</span><span class="op">&lt;</span><span class="ident">String</span><span class="op">&gt;</span>,

    <span class="attribute">#[<span class="ident">dynomite</span>(<span class="ident">skip_serializing_if</span> <span class="op">=</span> <span class="string">&quot;is_99&quot;</span>)]</span>
    <span class="ident">skip_if_99</span>: <span class="ident">u32</span>,
}

<span class="kw">fn</span> <span class="ident">is_99</span>(<span class="kw-2">&amp;</span><span class="ident">num</span>: <span class="kw-2">&amp;</span><span class="ident">u32</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">bool</span> {
    <span class="ident">num</span> <span class="op">=</span><span class="op">=</span> <span class="number">99</span>
}</pre></div>
</li>
<li>
<p><code>#[dynomite(default)]</code> - use <a href="https://doc.rust-lang.org/stable/std/default/trait.Default.html#tymethod.default"><code>Default::default</code></a> implementation of the field type
if the attribute is absent when deserializing from <code>Attributes</code></p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">dynomite::Attributes</span>;

<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Attributes</span>)]</span>
<span class="kw">struct</span> <span class="ident">Todos</span> {
    <span class="comment">// use Default value of the field if it is absent in DynamoDb (empty vector)</span>
    <span class="attribute">#[<span class="ident">dynomite</span>(<span class="ident">default</span>)]</span>
    <span class="ident">items</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">String</span><span class="op">&gt;</span>,
    <span class="ident">list_name</span>: <span class="ident">String</span>,
}</pre></div>
</li>
<li>
<p><code>#[dynomite(flatten)]</code> - flattens the fields of other struct that also derives <code>Attributes</code>
into the current struct.</p>
<p>üí° If this attribute is placed onto a field, no other <code>dynomite</code> attributes
are alowed on this field (this restriction may be relaxed in future).</p>
<p>This is reminiscent of <a href="https://serde.rs/attr-flatten.html"><code>#[serde(flatten)]</code></a>. The order of
declaration of <code>flatten</code>ed fields matters, if the struct has to fields with
<code>#[dynomite(flatten)]</code> attribute the one that appears higher in code will
be evaluated before the other one. This is crucial when you want to collect
additional properties into a map:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">dynomite</span>::{<span class="ident">Attributes</span>, <span class="ident">Item</span>};

<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Item</span>)]</span>
<span class="kw">struct</span> <span class="ident">ShoppingCart</span> {
    <span class="attribute">#[<span class="ident">dynomite</span>(<span class="ident">partition_key</span>)]</span>
    <span class="ident">id</span>: <span class="ident">String</span>,
    <span class="comment">// A separate struct to store data without any id</span>
    <span class="attribute">#[<span class="ident">dynomite</span>(<span class="ident">flatten</span>)]</span>
    <span class="ident">data</span>: <span class="ident">ShoppingCartData</span>,
    <span class="comment">// Collect all other additional attributes into a map</span>
    <span class="comment">// Beware that the order of declaration will affect the order of</span>
    <span class="comment">// evaluation, so this &quot;wildcard&quot; flatten clause should be the last member</span>
    <span class="attribute">#[<span class="ident">dynomite</span>(<span class="ident">flatten</span>)]</span>
    <span class="ident">remaining_props</span>: <span class="ident">Attributes</span>,
}

<span class="comment">// `Attributes` doesn&#39;t require neither of #[dynomite(partition_key/sort_key)]</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Attributes</span>)]</span>
<span class="kw">struct</span> <span class="ident">ShoppingCartData</span> {
    <span class="ident">name</span>: <span class="ident">String</span>,
    <span class="ident">total_price</span>: <span class="ident">u32</span>,
}</pre></div>
</li>
</ul>
<h4 id="fat-enums" class="section-header"><a href="#fat-enums">Fat enums</a></h4>
<p>Fat enums are naturally supported by <code>#[derive(Attribute)]</code>.
As for now, there is a limitation that the members of the enum must be
either unit or one-element tuple variants. This restriction will be relaxed
in future versions of <code>dynomite</code>.</p>
<p>Deriving <code>Attributes</code> on fat enums currently uses
<a href="https://serde.rs/enum-representations.html#internally-tagged">internally tagged enum pattern</a> (inspired by serde).
Thus, you have to explicitly specify the <strong>field name</strong> of enum tag
via the <code>tag</code> attribute on an enum.</p>
<p>For example, the following definition:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">dynomite::Attributes</span>;

<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Attributes</span>)]</span>
<span class="comment">// Name of the field where to store the discriminant in DynamoDB</span>
<span class="attribute">#[<span class="ident">dynomite</span>(<span class="ident">tag</span> <span class="op">=</span> <span class="string">&quot;kind&quot;</span>)]</span>
<span class="kw">enum</span> <span class="ident">Shape</span> {
    <span class="ident">Rectangle</span>(<span class="ident">Rectangle</span>),
    <span class="comment">// Use `rename` to change the **value** of the tag for a particular variant</span>
    <span class="comment">// by default the tag for a particular variant is the name of the variant verbatim</span>
    <span class="attribute">#[<span class="ident">dynomite</span>(<span class="ident">rename</span> <span class="op">=</span> <span class="string">&quot;my_circle&quot;</span>)]</span>
    <span class="ident">Circle</span>(<span class="ident">Circle</span>),
    <span class="ident">Unknown</span>,
}

<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Attributes</span>)]</span>
<span class="kw">struct</span> <span class="ident">Circle</span> {
    <span class="ident">radius</span>: <span class="ident">u32</span>,
}

<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Attributes</span>)]</span>
<span class="kw">struct</span> <span class="ident">Rectangle</span> {
    <span class="ident">width</span>: <span class="ident">u32</span>,
    <span class="ident">height</span>: <span class="ident">u32</span>,
}</pre></div>
<p>corresponds to the following representation in DynamoDB for each enum variant:</p>
<ul>
<li><code>Rectangle</code>:
<pre><code class="language-json">{
    &quot;kind&quot;: &quot;Rectangle&quot;,
    &quot;width&quot;: 42,
    &quot;height&quot;: 64
}
</code></pre>
</li>
<li><code>Circle</code>:
<pre><code class="language-json">{
    &quot;kind&quot;: &quot;my_circle&quot;,
    &quot;radius&quot;: 54
}
</code></pre>
</li>
<li><code>Unknown</code>:
<pre><code class="language-json">{
    &quot;kind&quot;: &quot;Unknown&quot;
}
</code></pre>
</li>
</ul>
<p>If you have a plain old enum (without any data fields), you should use
<a href="#deriveattribute"><code>#[derive(Attribute)]</code></a> instead.</p>
<h3 id="deriveattribute" class="section-header"><a href="#deriveattribute"><code>#[derive(Attribute)]</code></a></h3>
<p>Derives an implementation of <a href="trait.Attribute.html"><code>Attribute</code></a> for the plain enum.
If you want to use a fat enum see <a href="#fat-enums">this paragraph</a> instead.</p>
<p>The enum istelf will be represented as a string with the name of the variant
it represents.
In contrast, having <a href="deriveattributes"><code>#[derive(Attributes)]</code></a> on an enum
makes it to be represented as an object with a tag field,
which implies an additional layer of indirection.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">dynomite</span>::{<span class="ident">Attribute</span>, <span class="ident">Item</span>};

<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Attribute</span>)]</span>
<span class="kw">enum</span> <span class="ident">UserRole</span> {
    <span class="ident">Admin</span>,
    <span class="ident">Moderator</span>,
    <span class="ident">Regular</span>,
}

<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Item</span>)]</span>
<span class="kw">struct</span> <span class="ident">User</span> {
    <span class="attribute">#[<span class="ident">dynomite</span>(<span class="ident">partition_key</span>)]</span>
    <span class="ident">id</span>: <span class="ident">String</span>,
    <span class="ident">role</span>: <span class="ident">UserRole</span>,
}</pre></div>
<p>This data model will have the following representation in DynamoDB:</p>
<pre><code class="language-json">{
    &quot;id&quot;: &quot;d97de525-c81d-46d4-b945-d01b3a0f9165&quot;,
    &quot;role&quot;: &quot;Admin&quot;
}
</code></pre>
<p><code>role</code> field here may be any of <code>Admin</code>, <code>Moderator</code>, or <code>Regular</code> strings.</p>
<h2 id="rusoto-extensions" class="section-header"><a href="#rusoto-extensions">Rusoto extensions</a></h2>
<p>By importing the <a href="trait.DynamoDbExt.html">dynomite::DynamoDbExt</a> trait, dynomite
adds client interfaces for creating async Stream-based auto pagination interfaces.</p>
<h2 id="robust-retries" class="section-header"><a href="#robust-retries">Robust retries</a></h2>
<p>By importing the <a href="retry/trait.Retries.html">dynomite::Retries</a> trait, dynomite
provides an interface for adding configuration retry policies so your
rusoto DynamoDb clients.</p>
<h1 id="errors" class="section-header"><a href="#errors">Errors</a></h1>
<p>Some operations which require coercion from AWS to Rust types may fail which results in an
<a href="error/enum.AttributeError.html">AttributeError</a>.</p>
<h1 id="cargo-features" class="section-header"><a href="#cargo-features">Cargo Features</a></h1>
<p>This crate has a few cargo features of note.</p>
<h2 id="uuid" class="section-header"><a href="#uuid">uuid</a></h2>
<p>Enabled by default, the <code>uuid</code> feature adds support for implementing <code>Attribute</code> for
the <a href="https://crates.io/crates/uuid">uuid</a> crate‚Äôs type <code>Uuid</code>, a useful
type for producing and representing
unique identifiers for items that satisfy <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/bp-partition-key-design.html">effective characteristics for partition keys</a></p>
<h2 id="chrono" class="section-header"><a href="#chrono">chrono</a></h2>
<p>Enabled by default, the <code>chrono</code> feature adds an implementation of <code>Attribute</code> for
the std‚Äôs <a href="https://doc.rust-lang.org/std/time/struct.SystemTime.html">SystemTime</a> and chrono <a href="https://docs.rs/chrono/0.4.11/chrono/struct.DateTime.html"><code>DateTime</code></a> types which
internally use <a href="https://www.ietf.org/rfc/rfc3339.txt">rfc3339 timestamps</a>.</p>
<h2 id="derive" class="section-header"><a href="#derive">derive</a></h2>
<p>Enabled by default, the <code>derive</code> feature enables the use of the dynomite derive feature which
allows you to simply add <code>#[derive(Item)]</code> to your structs.</p>
<h2 id="rustls" class="section-header"><a href="#rustls">rustls</a></h2>
<p>Disabled by default, the <code>rustls</code> feature overrides Rusoto‚Äôs default tls
dependency on OpenSSL, replacing it with a <a href="https://crates.io/crates/rustls"><code>rustls</code></a> based tls implementation. When you
enable this feature. It will also enable <code>uuid</code> and <code>derive</code> by default.</p>
<p>To disable any of these features</p>
<pre><code class="language-toml">[dependencies.dynomite]
version = &quot;xxx&quot;
default-features = false
features = [&quot;feature-you-want&quot;]
</code></pre>
</div></details><h2 id="reexports" class="section-header"><a href="#reexports">Re-exports</a></h2>
<table><tr class="import-item"><td><code>pub use rusoto_dynamodb as dynamodb;</code></td><td class="docblock-short"></td></tr><tr class="import-item"><td><code>pub use crate::retry::<a class="trait" href="retry/trait.Retries.html" title="trait dynomite::retry::Retries">Retries</a>;</code></td><td class="docblock-short"></td></tr><tr class="import-item"><td><code>pub use crate::error::<a class="enum" href="error/enum.AttributeError.html" title="enum dynomite::error::AttributeError">AttributeError</a>;</code></td><td class="docblock-short"></td></tr></table><h2 id="modules" class="section-header"><a href="#modules">Modules</a></h2>
<table><tr class="module-item"><td><a class="mod" href="error/index.html" title="dynomite::error mod">error</a></td><td class="docblock-short"><p>Dynomite error types</p>
</td></tr><tr class="module-item"><td><a class="mod" href="retry/index.html" title="dynomite::retry mod">retry</a></td><td class="docblock-short"><p>Retry functionality</p>
</td></tr></table><h2 id="macros" class="section-header"><a href="#macros">Macros</a></h2>
<table><tr class="module-item"><td><a class="macro" href="macro.attr_map.html" title="dynomite::attr_map macro">attr_map</a></td><td class="docblock-short"><p>Creates a <code>HashMap&lt;String, AttributeValue&gt;</code> from a list of key-value pairs</p>
</td></tr></table><h2 id="traits" class="section-header"><a href="#traits">Traits</a></h2>
<table><tr class="module-item"><td><a class="trait" href="trait.Attribute.html" title="dynomite::Attribute trait">Attribute</a></td><td class="docblock-short"><p>A type capable of being converted into an or from and AWS <code>AttributeValue</code></p>
</td></tr><tr class="module-item"><td><a class="trait" href="trait.DynamoDbExt.html" title="dynomite::DynamoDbExt trait">DynamoDbExt</a></td><td class="docblock-short"><p>Extension methods for DynamoDb client types</p>
</td></tr><tr class="module-item"><td><a class="trait" href="trait.FromAttributes.html" title="dynomite::FromAttributes trait">FromAttributes</a></td><td class="docblock-short"><p>A type capable of being produced from a set of string keys and <a href="https://docs.rs/rusoto_dynamodb/*/rusoto_dynamodb/struct.AttributeValue.html"><code>AttributeValue</code></a>s.
Generally, you should not implement this trait manually.
Use <code>#[derive(Attributes/Item)]</code> to generate the proper implementation instead.</p>
</td></tr><tr class="module-item"><td><a class="trait" href="trait.IntoAttributes.html" title="dynomite::IntoAttributes trait">IntoAttributes</a></td><td class="docblock-short"><p>A type capable of being serialized into a set of string keys and <a href="https://docs.rs/rusoto_dynamodb/*/rusoto_dynamodb/struct.AttributeValue.html"><code>AttributeValue</code></a>s
Generally, you should not implement this trait manually.
Use <code>#[derive(Attributes/Item)]</code> to generate the proper implementation instead.</p>
</td></tr><tr class="module-item"><td><a class="trait" href="trait.Item.html" title="dynomite::Item trait">Item</a></td><td class="docblock-short"><p>A type which can be converted to and from a set of String keys and
<code>AttributeValues</code>.</p>
</td></tr></table><h2 id="types" class="section-header"><a href="#types">Type Definitions</a></h2>
<table><tr class="module-item"><td><a class="type" href="type.Attributes.html" title="dynomite::Attributes type">Attributes</a></td><td class="docblock-short"><p>Type alias for map of named attribute values</p>
</td></tr></table></section><section id="search" class="content hidden"></section><div id="rustdoc-vars" data-root-path="../" data-current-crate="dynomite" data-search-index-js="../search-index.js" data-search-js="../search.js"></div><script src="../main.js"></script></body></html>